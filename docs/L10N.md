# Localization (l10n) Guide

ORIGO supports multiple languages through internationalization (i18n) using [next-intl](https://next-intl-docs.vercel.app/).

## Supported Languages

- **English (en)** - Default language
- **Japanese (ja)** - 日本語

## User Experience

### Language Switcher

Users can switch between languages using the language switcher component available on:
- Home page (top navigation)
- Login page
- Register page

The language preference is maintained as users navigate through the application.

### URL Structure

The application uses locale-based routing:

- English (default): `https://example.com/` or `https://example.com/en/`
- Japanese: `https://example.com/ja/`

The middleware automatically detects and applies the appropriate locale.

## For Developers

### Architecture

The l10n implementation consists of:

1. **Configuration** (`i18n/config.ts`): Defines supported locales and default locale
2. **Request Handler** (`i18n/request.ts`): Configures next-intl request handling
3. **Middleware** (`middleware.ts`): Handles locale detection and routing
4. **Translation Files** (`messages/`): JSON files containing translations for each locale

### Directory Structure

```
ORIGO/
├── app/
│   ├── [locale]/           # Locale-specific pages
│   │   ├── layout.tsx      # Locale layout with NextIntlClientProvider
│   │   ├── page.tsx        # Home page
│   │   ├── login/
│   │   ├── register/
│   │   └── dashboard/
│   └── components/
│       └── LanguageSwitcher.tsx
├── i18n/
│   ├── config.ts           # Locale configuration
│   └── request.ts          # next-intl request configuration
├── messages/
│   ├── en.json             # English translations
│   └── ja.json             # Japanese translations
└── middleware.ts           # Locale routing middleware
```

### Adding New Translations

1. **Add translation keys to JSON files**:

```json
// messages/en.json
{
  "common": {
    "save": "Save",
    "cancel": "Cancel"
  }
}

// messages/ja.json
{
  "common": {
    "save": "保存",
    "cancel": "キャンセル"
  }
}
```

2. **Use translations in components**:

**Server Components**:
```tsx
import { getTranslations } from 'next-intl/server'

export default async function MyPage() {
  const t = await getTranslations('common')
  
  return <button>{t('save')}</button>
}
```

**Client Components**:
```tsx
'use client'
import { useTranslations } from 'next-intl'

export default function MyComponent() {
  const t = useTranslations('common')
  
  return <button>{t('save')}</button>
}
```

### Adding a New Language

1. **Add locale to configuration** (`i18n/config.ts`):
```typescript
export const locales = ['en', 'ja', 'fr'] as const
```

2. **Create translation file**:
```bash
cp messages/en.json messages/fr.json
# Edit messages/fr.json with French translations
```

3. **Update LanguageSwitcher** (`app/components/LanguageSwitcher.tsx`):
```typescript
const localeLabels: Record<Locale, string> = {
  en: 'English',
  ja: '日本語',
  fr: 'Français'
}
```

### Translation Key Naming Convention

Use descriptive, hierarchical keys:

```json
{
  "namespace": {
    "section": {
      "element": "Translation"
    }
  }
}
```

Example:
```json
{
  "home": {
    "hero": {
      "title": "Welcome to ORIGO"
    },
    "features": {
      "scheduleAnything": {
        "title": "Schedule anything",
        "description": "Run TypeScript or JavaScript..."
      }
    }
  }
}
```

### Dynamic Values

Use placeholders for dynamic content:

```json
{
  "welcome": "Welcome, {name}!",
  "itemCount": "You have {count} items"
}
```

```tsx
t('welcome', { name: 'John' })
t('itemCount', { count: 5 })
```

### Pluralization

next-intl supports ICU message format for pluralization:

```json
{
  "items": "{count, plural, =0 {No items} =1 {One item} other {# items}}"
}
```

## Testing

### Manual Testing

1. Start the development server:
```bash
npm run dev
```

2. Visit different locale URLs:
   - `http://localhost:3000/` (default locale)
   - `http://localhost:3000/ja/` (Japanese)

3. Use the language switcher to toggle between languages

### Automated Testing

Translation coverage can be tested by:
1. Ensuring all keys exist in all locale files
2. Checking for missing translations
3. Verifying translation placeholders match

## Best Practices

1. **Keep translations synchronized**: Ensure all locale files have the same keys
2. **Use namespaces**: Organize translations by feature/page
3. **Avoid hardcoded strings**: Always use translation keys
4. **Context matters**: Consider cultural differences, not just literal translations
5. **Test with actual content**: Some languages may require more space (e.g., German)
6. **RTL support**: Consider adding RTL language support in the future

## Troubleshooting

### "Cannot find message" error

- Ensure the translation key exists in the active locale file
- Check the namespace is correct
- Verify the locale file is properly formatted JSON

### Language switcher not working

- Check that the locale is defined in `i18n/config.ts`
- Verify middleware is properly configured
- Check browser console for routing errors

### Translations not updating

- Clear Next.js cache: `rm -rf .next`
- Restart the development server
- Check for JSON syntax errors in message files

## Resources

- [next-intl Documentation](https://next-intl-docs.vercel.app/)
- [Next.js Internationalization](https://nextjs.org/docs/app/building-your-application/routing/internationalization)
- [ICU Message Format](https://unicode-org.github.io/icu/userguide/format_parse/messages/)
